/*******************************
  1ï¸âƒ£ MONOTONIC PRINT (Skip 0)
********************************/
// Input: [4,0,1,4,2,7,0]
// Output: 4 1 4 2 7
const monotonicArr = (nums) => {
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] !== 0) console.log(nums[i]);
  }
};
monotonicArr([4, 0, 1, 4, 2, 7, 0]);


/*********************************
 2ï¸âƒ£ MISSING NUMBERS IN A RANGE
*********************************/
// Input: [4,0,1,4,2,7,8]
// Output: [3,5,6]
const missingNumbers = (nums) => {
  const unique = [...new Set(nums)].sort((a,b)=>a-b);
  const missing = [];
  for (let i = 0; i < unique.length - 1; i++) {
    let curr = unique[i];
    let next = unique[i + 1];
    for (let j = curr + 1; j < next; j++) missing.push(j);
  }
  return missing;
};
console.log(missingNumbers([4, 0, 1, 4, 2, 7, 8]));


/*********************************
 3ï¸âƒ£ MOVE ZEROS TO END
*********************************/
// Input: [0,2,0,3,4,0,5,6,0,7]
// Output: [2,3,4,5,6,7,0,0,0,0]
const moveZeros = (nums) => {
  const nonZero = nums.filter(n => n !== 0);
  const zeros = nums.filter(n => n === 0);
  return [...nonZero, ...zeros];
};
console.log(moveZeros([0,2,0,3,4,0,5,6,0,7]));


/*********************************
 4ï¸âƒ£ ROTATE ARRAY K TIMES
*********************************/
// Input: nums=[1,2,3,4,5], k=2
// Output: [4,5,1,2,3]
const rotate = (nums, k) => {
  for (let i = 0; i < k; i++) {
    nums.unshift(nums.pop());
  }
  return nums;
};
console.log(rotate([1,2,3,4,5],2));


/*********************************
 5ï¸âƒ£ SORTED SQUARES
*********************************/
// Input: [-4,-1,0,3,10]
// Output: [0,1,9,16,100]
const sortedSquares = (nums) =>
  nums.map(n => n * n).sort((a, b) => a - b);

console.log(sortedSquares([-4,-1,0,3,10]));


/*********************************
 6ï¸âƒ£ OBJECT â†’ ARRAY
*********************************/
const obj = {0:'hello',1:'here',2:'here',3:'is',4:'my',5:'hello'};
const objToArr = Object.values(obj);
console.log(objToArr);


/*********************************
 7ï¸âƒ£ MOST FREQUENT ELEMENT
*********************************/
// Input: ['a','b','a','c','b','a']
// Output: 'a'
const frequencyFinder = (arr) => {
  const count = {};
  let max = 0, ans = null;

  arr.forEach(c => {
    count[c] = (count[c] || 0) + 1;
    if (count[c] > max) {
      max = count[c];
      ans = c;
    }
  });

  return ans;
};
console.log(frequencyFinder(['a','b','a','c','b','a']));


/*********************************
 8ï¸âƒ£ LEAST FREQUENT CHARACTER
*********************************/
// Input: "loveleetcode"
// Output: { l:2, o:2, v:1, e:4, t:1, c:1 } â†’ 'v'
const firstUniqChar = (s) => {
  const map = {};
  s.split('').forEach(c => (map[c] = (map[c] || 0) + 1));

  let min = Infinity, res = null;
  for (const [key, val] of Object.entries(map)) {
    if (val < min) {
      min = val;
      res = key;
    }
  }
  return { map, "least repeating": res };
};
console.log(firstUniqChar("loveleetcode"));


/*********************************
 9ï¸âƒ£ ARRAY â†’ OBJECT
*********************************/
const arr1 = ['hello','here','here','is','my','hello'];
const arrToObj = {};
arr1.forEach((v, i) => (arrToObj[i] = v));
console.log(arrToObj);


/*********************************
 ðŸ”Ÿ FILTER & MERGE WITH STATUS
*********************************/
const values = {
  contactItem: [
    { contactItemSeq: 1, contactItemDetails: "Details 1" },
    { contactItemSeq: 2, contactItemDetails: "Details 2" },
    { contactItemSeq: 3, contactItemDetails: "Details 3" }
  ]
};
const editObj = {
  contactItem: [
    { contactItemSeq: 2, contactItemDetails: "Details 2 edited" },
    { contactItemSeq: 4, contactItemDetails: "Details 4" },
    { contactItemSeq: 5, contactItemDetails: "Details 5" }
  ]
};
const seq = values.contactItem.map(i => i.contactItemSeq);
const resultFilter = editObj.contactItem.map(item => ({
  ...item,
  status: seq.includes(item.contactItemSeq) ? "filtered" : "unfiltered"
}));
console.log(resultFilter);


/*********************************
 1ï¸âƒ£1ï¸âƒ£ BINARY SEARCH
*********************************/
const binarySearch = (arr, target) => {
  let left = 0, right = arr.length - 1;

  while (left <= right) {
    let mid = Math.floor((left + right) / 2);
    if (arr[mid] === target) return mid;
    if (arr[mid] < target) left = mid + 1;
    else right = mid - 1;
  }
  return -1;
};
console.log(binarySearch([2,4,6,8,10,12],10));


/*********************************
 1ï¸âƒ£2ï¸âƒ£ FLATTEN NESTED ARRAY (RECURSION)
*********************************/
const flattenNested = (arr) => {
  let flat = [];
  arr.forEach(item =>
    Array.isArray(item)
      ? flat.push(...flattenNested(item))
      : flat.push(item)
  );
  return flat;
};
console.log(flattenNested([1,[2,[3]],4,[5,[6,7]]])); 


/*********************************
 1ï¸âƒ£3ï¸âƒ£ FILTER KEYS USING NUMBERS
*********************************/
const dataMap = {2:'abc',3:'def',5:'ghi',9:'jkl',7:'pqr'};
const filterObj = (num) => {
  let str = "";
  num.split('').forEach(n => {
    if (dataMap[n]) str += dataMap[n];
  });
  return str;
};
console.log(filterObj("35"));  // "defghi"


/*********************************
 1ï¸âƒ£4ï¸âƒ£ FIBONACCI
*********************************/
const fibonacci = (n) => {
  const arr = [0, 1];
  for (let i = 2; i < n; i++) arr.push(arr[i - 1] + arr[i - 2]);
  return arr;
};
console.log(fibonacci(7));


/*********************************
 1ï¸âƒ£5ï¸âƒ£ FACTORIAL
*********************************/
const factorial = (n) => {
  let f = 1;
  for (let i = 2; i <= n; i++) f *= i;
  return f;
};
console.log(factorial(5));


/*********************************
 1ï¸âƒ£6ï¸âƒ£ CONSECUTIVE ONES
*********************************/
const consecutiveOnes = (arr) => {
  let max = 0, curr = 0;
  arr.forEach(n => {
    if (n === 1) curr++;
    else curr = 0;
    max = Math.max(max, curr);
  });
  return max;
};
console.log(consecutiveOnes([1,1,0,1,1,1]));


/*********************************
 1ï¸âƒ£7ï¸âƒ£ REVERSE NUMBER WITHOUT STRING
*********************************/
const reverseNumber = (num) => {
  let rev = 0;
  while (num > 0) {
    rev = rev * 10 + (num % 10);
    num = Math.floor(num / 10);
  }
  return rev;
};
console.log(reverseNumber(9876));


/*********************************
 1ï¸âƒ£8ï¸âƒ£ LONGEST COMMON PREFIX
*********************************/
const longestCommonPrefix = (arr) => {
  let prefix = arr[0];
  for (let i = 1; i < arr.length; i++) {
    while (!arr[i].startsWith(prefix)) {
      prefix = prefix.slice(0, -1);
      if (!prefix) return "";
    }
  }
  return prefix;
};
console.log(longestCommonPrefix(["flower","flow","flight"]));


/*********************************
 1ï¸âƒ£9ï¸âƒ£ LONGEST SUBSTRING (NO REPEAT)
*********************************/
const longestSubstring = (s) => {
  let curr = [], max = 0;
  for (let c of s) {
    if (curr.includes(c)) curr = curr.slice(curr.indexOf(c) + 1);
    curr.push(c);
    max = Math.max(max, curr.length);
  }
  return max;
};
console.log(longestSubstring("abcadabb"));


/*********************************
 2ï¸âƒ£0ï¸âƒ£ REMOVE STAR (delete previous)
*********************************/
const removeStars = (str) => {
  let res = "";
  for (let c of str) res = c === "*" ? res.slice(0, -1) : res + c;
  return res;
};
console.log(removeStars("abc*k*II*")); // "abI"


/*********************************
 2ï¸âƒ£1ï¸âƒ£ COMPRESS STRING (a3b2c4)
*********************************/
const compress = (str) => {
  let res = "", count = 1;
  for (let i = 1; i <= str.length; i++) {
    if (str[i] === str[i - 1]) count++;
    else {
      res += str[i - 1] + count;
      count = 1;
    }
  }
  return res;
};
console.log(compress("aaabbccccd"));


// Input: [1,3,5], [2,4,6]
// Output: [1,2,3,4,5,6]

function merge(arr1, arr2) {
  let i = 0, j = 0, result = [];

  while (i < arr1.length && j < arr2.length) {
    if (arr1[i] <= arr2[j]) result.push(arr1[i++]);
    else result.push(arr2[j++]);
  }

  return result.concat(arr1.slice(i)).concat(arr2.slice(j));
}


// Input: "listen", "silent"
// Output: true

function isAnagram(a, b) {
  return a.split("").sort().join("") === b.split("").sort().join("");
}


// Input: "I am learning JavaScript everyday"
// Output: "JavaScript"

function longestWord(str) {
  let words = str.split(" ");
  let longest = "";

  for (let w of words) {
    if (w.length > longest.length) longest = w;
  }

  return longest;
}


// Input: [5, 7, 2, 9, 1]
// Output: 7

function secondLargest(arr) {
  let max = -Infinity;
  let second = -Infinity;

  for (let n of arr) {
    if (n > max) {
      second = max;
      max = n;
    } else if (n > second && n !== max) {
      second = n;
    }
  }

  return second;
}


// Input: "banana"
// Output: { b:1, a:3, n:2 }

function freq(str) {
  let map = {};

  for (let ch of str) {
    map[ch] = (map[ch] || 0) + 1;
  }

  return map;
}



// Input: [3,4,4,3,6,3]
// Output: [3,4,6]

function removeDup(arr) {
  let result = [];

  for (let n of arr) {
    if (!result.includes(n)) {
      result.push(n);
    }
  }

  return result;
}



// Input: "MendixDeveloper"
// Output: { vowels: 6, consonants: 10 }

function countVC(str) {
  let vowels = "aeiouAEIOU";
  let v = 0, c = 0;

  for (let ch of str) {
    if (vowels.includes(ch)) v++;
    else if (/[a-zA-Z]/.test(ch)) c++;
  }

  return { vowels: v, consonants: c };
}



// Input: [-2,1,-3,4,-1,2,1,-5,4]
// Output: 6   (subarray: [4,-1,2,1])

function maxSubArray(arr) {
  let max = arr[0];
  let curr = 0;

  for (let n of arr) {
    curr += n;
    max = Math.max(max, curr);
    if (curr < 0) curr = 0;
  }

  return max;
}



// Input: "{[()]}"
// Output: true

function isBalanced(str) {
  const stack = [];
  const map = { ")": "(", "]": "[", "}": "{" };

  for (let ch of str) {
    if (map[ch]) {
      if (stack.pop() !== map[ch]) return false;
    } else {
      stack.push(ch);
    }
  }

  return stack.length === 0;
}
